/**
 * Created by John Hall on 6/29/15
 * Copyright (c) 2015 Maponics. All rights reserved.
 */
"use strict";

/** @ignore */
var Debugger = require('../modules/debugger'),
	Contact = require('../modules/Contact'),
	fs = require('fs'),
	config = (fs.existsSync('../modules/config.json'))? 
				require('../modules/config.json') :
				require('../modules/config'),
	join = require('path').join,
	hash = require('md5'),
	pw = require('password-generator'),
	pg = require('pg'),
	nodemailer = require('nodemailer'),
	smtpTransport = require('nodemailer-smtp-transport');

pg.requestError = function (error, res, sql) {
	Debugger.on = true;
	Debugger.log( "ERROR!" );
	Debugger.log( (error.stack || error) + '\n' + sql);
};

/** 
 * @class Request
 */
function Request() {
	Debugger.on = true;
	
	/* STATIC => class constants, fields & functions */
	/** @ignore */
	var res = {}, // req & res are custom objects, NOT Express properties
		req = (req && req.hostname)? req : {}, 	// UNLESS req already exists!				
		contactData,
	 	mailTransporter; 

	if( typeof arguments[0] !== "object" ) {
		Debugger.log( "Non-object use of Request()" );
		
	} else if( arguments[0].hostname ) {
		Debugger.log( arguments[1] );
		
		/* Called as handler */
		req = arguments[0];
		contactData = arguments[1];
		
	} else {
		Debugger.log( arguments[0] );
		contactData = arguments[0];
	}
	
	if(! req.hostname ) {
		req.hostname = 'feedback.maponics.com';
		//req.hostname = 'localhost'; // for local testing
	
		/* AWS db credentials */
		req.connection = 'postgres://' +
			config[req.hostname].username + ':' +
			config[req.hostname].password + '@' +
			config[req.hostname].host + '/' +
			config[req.hostname].instance;
	
		req.query = {};
	}
	
	mailTransporter = nodemailer.createTransport({
		host: 'smtp.office365.com',
		port: 587,
		auth: {
			user: 'crowd@maponics.com',
			pass: 'Feedback1234'
		}
	});

	Request.createPass = function() {
		return pw(3, false, /[maponix]/) + pw(3, false, /\d/) + pw(3, false, /[a-z]/);
	};
	
	Request.authPass = function( req, res, cid, hashN, hashP, done ) {
		Debugger.on = true;
		
		var transaction_put = function (error, client, release) {
			var sql = 'SELECT s.cid AS cid, s.nextnonce AS nextnonce '+
						'FROM ' + config[req.hostname].shadow.schema + '."' + config[req.hostname].shadow.table + '" s '+
						'WHERE s.cid='+ cid +" AND s.pass='"+ hash(hashP) +"';";
			
			Debugger.log( { 
				cid: cid, 
				hashN: hashN, 
				hashP: hashP,
				hashPass: hash(hashP)
			} );

			var query = function (error, result) {
				release();

				if( !error && result.rows[0] !== undefined && 'cid' in result.rows[0] ) {
					var nextPass = hashN,
						nonce = result.rows[0]['nextnonce'],
						nextnonce = Request.createPass();

					var transaction_get = function (error, client, release) {
						var sql = 'UPDATE ' + config[req.hostname].shadow.schema + '."'+ config[req.hostname].shadow.table +'" SET '+  	 
								"pass='"+ nextPass +"', nonce='"+ nonce +"', nextnonce='"+ nextnonce +"', modified=CURRENT_TIMESTAMP "+
								'WHERE cid='+ result.rows[0]['cid'] +';'+
								"SELECT c.cid AS cid, "+
									"c.first_name AS first_name, "+
									"c.last_name AS last_name, "+
									"c.role AS role, "+
									"c.organization AS organization, "+
									"c.email AS email, "+
									"c.phone AS phone, "+
									"TO_CHAR(c.join_date, 'DD MONTH, YYYY') AS join_date, "+
									"DATE_PART('epoch', c.created) AS created, "+
									"DATE_PART('epoch', c.modified) AS modified "+
								' FROM ' + config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" c '+
								' WHERE c.cid='+ result.rows[0]['cid'] +';';

						var query = function (error, result) {
							release();

							if (error) { 
								pg.requestError(error, res, sql);
								if( done ) done(null, false, { message: 'Invalid password.' });
								else res.status(500).send({ Error: 'Invalid password.' });

							} else if (result.rows[0] !== undefined) {
								Debugger.log( result.rows[0], "Returned contact: $1" );

								for (var i = 0; i < result.rows.length; i++) {
									var contactData = ( 'cid' in result.rows[i] ) ? result.rows[i] : false,
										contactObject = new Contact(contactData);

									for (var prop in contactObject) {
										if (typeof contactObject[prop] === 'string') {
											contactObject[prop] = contactObject[prop]
												.replace(/\&apos\;/g, "'")
												.replace(/\&quot\;/g, "'");
										}
									}

									if( done ) done(null, contactObject);
									else res.status(200).send([contactObject]);
								}

								return true;

							} else {
								Debugger.log('No rows received for: \n' + sql);
								if( done ) done(null, false, { message: "No Contact found for this email" });
								else res.status(500).send({ Error: "No Contact found for this email" });
							}

							return true;
						};

						if (error) { // if() {BRACKETS!}
							//return pg.requestError(error, res, sql);
							pg.requestError(error, res, sql);
							if( done ) done(null, false, { message: 'Invalid password.' });
							else res.status(500).send({ Error: 'Invalid password.' });
							
						} else client.query(sql, query); // Don't return this call... all of these pg methods are empty promises with no real return value
						
						return true;
					};

					pg.connect(req.connection, transaction_get);
					
				} else if( error ) {
					//return pg.requestError(error, res, sql);
					pg.requestError(error, res, sql);
					if( done ) done(null, false, { message: 'Invalid password.' });
					else res.status(500).send({ Error: 'Invalid password.' });
					
				} else {
					if( done ) done(null, false, { message: 'Invalid password.' });
					else res.status(500).send({ Error: 'Invalid password.' });
				}
					
				return true;
			};

			if (error) { // if() {BRACKETS!}
				//return pg.requestError(error, res, sql);
				pg.requestError(error, res, sql);
				done(null, false, { message: 'Invalid password.' });

			} else client.query(sql, query); // Don't return this call... all of these pg methods are empty promises with no real return value
						
			return true;
		};

		pg.connect(req.connection, transaction_put);
				
		return true;
	};

	Request.resetPass = function( request ) {
		var cid = request.cid;
		if (parseInt(cid) !== parseInt(cid))
			return pg.requestError("Cannot create password for invalid contact", res, "");
		
		var password = request.pass;
		
		var first = Request.createPass(),
			nextnonce = Request.createPass();
		
		var response = hash(first + password), 
			cnonce = hash(hash(nextnonce + password));
		
		var hashMail = hash(request.email),
			hashPass = cnonce,
			nonce = nextnonce;
//			nextnonce = Request.createPass();

		var transaction = function (error, client, release) {
			var sql = "No SQL transactions were attempted";

			if( error ) {
				return pg.requestError(error, res, sql);
			} else {
				sql = 'DELETE FROM ' + config[req.hostname].request.schema + '."' + config[req.hostname].request.table + '" '+
					"WHERE email='"+ request.email +"'; "+
					'UPDATE ' + config[req.hostname].shadow.schema + '."'+ config[req.hostname].shadow.table +'" SET '+  	 
						"pass='"+ hashPass +"', nonce='"+ nonce +"', nextnonce='"+ nextnonce +"', modified=CURRENT_TIMESTAMP "+
						'WHERE cid='+ cid +' '+
					'RETURNING cid;';

				var query = function (error, result) {
					release();

					Debugger.on = true;
					Debugger.log(sql);

					if( result && result.rows && result.rows[0] !== undefined ) {
						Debugger.log( result.rows, "Pass approved: $1" );
						Request.notifyContact( request, "Maponics Feedback notification",
"Hello $first_name,<br />\
The password for your Maponics Feedback account has been reset.\n\
Please return to http://$host and signin with your email address and the following password:\n\
$password<br />\
<br />\
Thank you,<br />\
The Maponics Feedback Team" );
					} else if( error ) {
						return pg.requestError(error, res, sql);
					} else {
						Debugger.log('No rows received for: \n' + sql);
					}
					
					return true;
				};

				client.query(sql, query); // Don't return this call... all of these pg methods are empty promises with no real return value
						
				return true;
			}
		};

		pg.connect(req.connection, transaction);

		return true;		
	};

	Request.storePass = function( request ) {
		var cid = request.cid;
		if (parseInt(cid) !== parseInt(cid))
			return pg.requestError("Cannot create password for invalid contact", res, "");
		
		var password = request.pass;
		
		var first = Request.createPass(), nextnonce = Request.createPass();
		
		var response = hash(first + password), 
			cnonce = hash(hash(nextnonce + password));
		
		var hashMail = hash(request.email),
			hashPass = cnonce,
			nonce = nextnonce,
			nextnonce = Request.createPass();

		var transaction = function (error, client, release) {
			var sql = "No SQL transactions were attempted";

			if( error ) {
				return pg.requestError(error, res, sql);
			} else {
				sql = 'DELETE FROM ' + config[req.hostname].request.schema + '."' + config[req.hostname].request.table + '" '+
					"WHERE email='"+ request.email +"'; "+
					'INSERT INTO ' + config[req.hostname].shadow.schema + '."' + config[req.hostname].shadow.table + '" (' +
					'cid, mail, pass, nonce, nextnonce, created, modified' +
					') ' +
					'VALUES (' +
					cid +", '"+ hashMail +"', '"+ hashPass +"', '"+ nonce +"', '"+ nextnonce +"', "+
					'CURRENT_TIMESTAMP, CURRENT_TIMESTAMP' +
					')' +
					' RETURNING cid;';

				var query = function (error, result) {
					release();

					Debugger.on = true;
					Debugger.log(sql);

					if( result && result.rows && result.rows[0] !== undefined ) {
						Debugger.log( result.rows, "Pass approved: $1" );
						Request.notifyContact( request, "Congratulations!  You are now a registered user on our site.",
"Hello $first_name,<br />\
Thank you for choosing to participate in the Maponics Feedback Platform.  Your account has been activated. To begin submitting feedback, please return to http://$host and login using your email address and the following password:<br />\
$password<br/>\
<br />\
Thank you,<br />\
The Maponics Feedback Team" );
                        
					} else if( error && error.stack.match(/Words_pkey/) ) {
					   	Request.resetPass( request );
						return true;
						
					} else Debugger.log('No rows received for: \n' + sql);
					
					return true;
				};

				client.query(sql, query);
						
				return true;
			}
		};

		pg.connect(req.connection, transaction);

		return true;		
	};

	Request.notifyContact= function( request, subject, message ) {		
		var message = message.replace(/\$email/g, request.email)
							.replace(/\$first_name/, request.first_name)
							.replace(/\$password/g, request.pass)
							.replace(/\$host/g, req.hostname),
			notification = fs.createWriteStream(join(__dirname, '../notification.txt'), { flags: 'a' });
        
        message += '<br /><br />\
<strong>Data For Life®</strong> – Maponics defines and characterizes real-life geographies in the communities where people live, work and play. Products include Neighborhoods, Residential Boundaries, Schools, Social Places, ZIP Code Boundaries and more, as well as Context® data that helps define local character. We solve display, search and analytic challenges faced by real estate, local search, mobile marketing and other industries. Learn how we can help you at <a href="http://maponics.com">maponics.com</a> or call us at <a href="tel:18007625158">1-800-762-5158</a>.<br />\
<br />\
Legal Items: © 2015. This email and any files transmitted with it are confidential and intended solely for the use of the individual or entity to whom they are addressed. Any pricing information, product samples, or customer specifications contained in this message are considered privileged, confidential and protected from disclosure and/or forwarding to others outside your organization. If you have received this communication in error, please notify Maponics immediately by replying to the sender named above and deleting this message from your computer.<br />\
<br />\
<strong>Maponics, LLC | 35 Railroad Row, White River Junction, Vermont 05001, United States</strong>';
		
		mailTransporter.sendMail(
			{
				from: 'Maponics Feedback <crowd@maponics.com>',
				to: request.email,
				subject: 'Maponics Feedback notification',
				html: message
			}, 
			function( error, info ) {
			try {
				Debugger.on = true;
				notification.write( (new Date()) +"\n" );
				notification.write( message );
				notification.end('\n');
				
				if( error ){
					Debugger.log( error );
					return false;
				}
				
				return true;
			} catch(e) { Debugger.log( e.stack ); }
			}
		);
	};

	/* this => instance properties & methods */	
	Request.prototype.init = function( contactData ) {
		var tempContact = new Contact(contactData);
		
		this.email = tempContact.email;
		this.first_name = tempContact.first_name;
		this.last_name = tempContact.last_name;
		this.phone = tempContact.phone;
		this.organization = tempContact.organization;
		
		return this;
	};
	
	Request.prototype.approve = function() {
		var request = this;
		
		/* Save new Contact with contactData */
		(new Contact(request)).save(req, res, function( req, res ) {
			Debugger.on = true;
			
			Debugger.log( req.that, "Callback triggered with: $1" );
			
			if( res.that && 'cid' in res.that ) {
				Debugger.log( res.that, "Attempting to create this contact: $1" );
				request.cid = res.that.cid;
				request.pass = Request.createPass();
				Request.storePass( request );
				
			} else if( req.that && req.that.error ) {
				var error = req.that.error;
				request.cid = res.contact ? res.contact.cid : req.that.cid;
				
				if (error.stack.match(/Contacts_unique_email/) !== null) {
					/* This contact already exist, so
					 * reset pass...
					 */
					Debugger.log( request, "Attempting to reset pass for: $1" );
					request.pass = Request.createPass();
					Request.resetPass( request );
					
				} else pg.requestError(error, res, "");
			}
			
			return true;
		});
		
		return this;
	};

	Request.prototype.reject = function() {
		var request = this;
		
		var transaction = function (error, client, release) {
			var sql = "No SQL transactions were attempted";

			if( error ) {
				return pg.requestError(error, res, sql);
			} else {
				sql = 'DELETE FROM ' + config[req.hostname].request.schema + '."' + config[req.hostname].request.table + '" '+
					"WHERE email='"+ request.email +"'; ";

				var query = function (error, result) {
					release();

					Debugger.on = true;
					Debugger.log(sql);

					if( error ) {
						return pg.requestError(error, res, sql);
					} else {
						Debugger.log( result.rows, "Pass rejected: $1" );
						Request.notifyContact( request, "Maponics Feedback notification",
"Hello $first_name,<br />\
We appreciate your interest in the Maponics Feedback Platform, however we can not approve your request for user access at this time. If you have further questions or wish to contact Maponics regarding this decision, please email crowd@maponics.com.<br />\
<br />\
Thank you,<br />\
The Maponics Feedback Team" );
					}
					
					return true;
				};

				client.query(sql, query); // Don't return this call... all of these pg methods are empty promises with no real return value
						
				return true;
			}
		};

		pg.connect(req.connection, transaction);
		
		return this;
	};
	
	Request.prototype.update = function( cid, newEmail, oldEmail ) {
		/* This does not update the contact Request, but rather the 
		 * email field of the corresponding record in shadow.Words
		 */
		var request = this;
		
		if (parseInt(cid) !== parseInt(cid))
			return pg.requestError("Cannot update email for invalid contact: "+ cid, res, "");
		
		Debugger.log({
			newEmail: newEmail,
			oldEmail: oldEmail
		});
		
		var hashMail = hash(newEmail);

		var transaction = function (error, client, release) {
			var sql = "No SQL transactions were attempted";

			if( error ) {
				return pg.requestError(error, res, sql);
			} else {
				sql = 'UPDATE ' + config[req.hostname].shadow.schema + '."'+ config[req.hostname].shadow.table +'" SET '+  	 
						"mail='"+ hashMail +"', modified=CURRENT_TIMESTAMP "+
						'WHERE cid='+ cid +' '+
					'RETURNING cid;';

				var query = function (error, result) {
					release();

					Debugger.on = true;
					Debugger.log(sql);
					Debugger.log( "Host: "+ req.hostname );

					if( result && result.rows && result.rows[0] !== undefined ) {
						Debugger.log( result.rows, "Email updated: $1" );
						var old = {}
						for( var o in request ) {
							if( request[o] === newEmail ) old[o] = oldEmail;
						 	else old[o] = request[o];
						}
						Request.notifyContact( old, "Maponics Feedback notification",
"Hello $first_name,<br />\
The email address for your Maponics Feedback account has been changed to "+ newEmail +"<br/>\
<br />\
Thank you,<br />\
The Maponics Feedback Team" );
						
						Request.notifyContact( request, "Maponics Feedback notification",
"Hello $first_name,<br />\
The email address for your Maponics Feedback account has been changed to $email.<br/>\
<br />\
Thank you,<br />\
The Maponics Feedback Team" );
						
					} else if( error ) {
						return pg.requestError(error, res, sql);
					} else {
						Debugger.log('No rows received for: \n' + sql);
					}
					
					return true;
				};

				client.query(sql, query); // Don't return this call... all of these pg methods are empty promises with no real return value
						
				return true;
			}
		};

		pg.connect(req.connection, transaction);

		return true;
	};
	
	return this.init(contactData);
}

module.exports = Request;
