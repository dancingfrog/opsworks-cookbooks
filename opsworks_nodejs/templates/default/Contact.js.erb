/**
 * Created by John Hall on 5/21/15
 * Contributions from John Campbell on 6/15/15
 * Copyright (c) 2015 Maponics. All rights reserved.
 */
'use strict';

/** @ignore */
var Debugger = require('../modules/debugger'),
	Summary = require('../modules/Summary'),
	fs = require('fs'),
	config = (fs.existsSync('../modules/config.json'))? 
				require('../modules/config.json') :
				require('../modules/config'),
	join = require('path').join,
	md5 = require('md5'),
	pg = require('pg'),
	request = require('request'),
	nodemailer = require('nodemailer'),
	smtpTransport = require('nodemailer-smtp-transport');

pg.contactError = function (error, res, sql) {
	Debugger.on = true;
	Debugger.log('ERROR!');
	Debugger.log((error.stack || error) + '\n' + sql);
	res.status(500).send({'Error': (error.stack || error)});
	return true;
};

/**
 * @class Contact
 */
function Contact() {
	Debugger.on = true;

	/* STATIC => class constants, fields & functions */
	/** @ignore */
	var req, res,
		page = 0,
		contactData,
		Request = require('../modules/Request');

	if (typeof arguments[0] !== 'object')
		return null;

	else if (typeof arguments[0].get === 'function') {
		/* Called as route handler */
		req = arguments[0];
		res = arguments[1];

		/* Query parameter for getAllContacts() method */
		page = req.query.page || 0;

		contactData = {
			cid: req.query.cid,
			first_name: req.query.first_name,
			last_name: req.query.last_name,
			role: req.query.role,
			organization: req.query.organization,
			email: req.query.email,
			phone: req.query.phone
		};
		
	} else
		contactData = arguments[0];

	Contact.notify = function (email, subject, message) {
        var message = message +'\n\
<br /><br />\
<strong>Data For Life®</strong> – Maponics defines and characterizes real-life geographies in the communities where people live, work and play. Products include Neighborhoods, Residential Boundaries, Schools, Social Places, ZIP Code Boundaries and more, as well as Context® data that helps define local character. We solve display, search and analytic challenges faced by real estate, local search, mobile marketing and other industries. Learn how we can help you at <a href="http://maponics.com">maponics.com</a> or call us at <a href="tel:18007625158">1-800-762-5158</a>.<br />\
<br />\
Legal Items: © 2015. This email and any files transmitted with it are confidential and intended solely for the use of the individual or entity to whom they are addressed. Any pricing information, product samples, or customer specifications contained in this message are considered privileged, confidential and protected from disclosure and/or forwarding to others outside your organization. If you have received this communication in error, please notify Maponics immediately by replying to the sender named above and deleting this message from your computer.<br />\
<br />\
<strong>Maponics, LLC | 35 Railroad Row, White River Junction, Vermont 05001, United States</strong>';
		
		var notification = fs.createWriteStream(join(__dirname, '../contacts_report.txt'), { flags: 'a' });
				
		notification.write( "\n\n"+ (new Date()) +"\n" );
		notification.write( message );
		notification.end('\n');
        
		nodemailer.createTransport({
			host: 'smtp.office365.com',
			port: 587,
			auth: {
				user: 'crowd@maponics.com',
				pass: 'Feedback1234'
			}
		}).sendMail(
			{
				from: 'Maponics Feedback <crowd@maponics.com>',
				to: email,
				subject: subject,
				html: message
			},
			function( error, info ) {
				Debugger.on = true;

				if (error) Debugger.log(error);
				
				return true;
			}
		);

		return true;
	};

	Contact.notifyManager = function (req, requestList) {
		pg.connect(req.connection, function (error, client, done) {
			var sql =
				'SELECT ' +
					'id, ' +
					'email ' +
				'FROM ' + config[req.hostname].manager.schema + '."' + config[req.hostname].manager.table + '" ' +
				'ORDER BY id;';

			if (error) {
				pg.contactError(error, res, sql);

			} else {
				client.query(sql, function (error, result) {
					if (error)
						pg.contactError(error, res, sql);

					else if (result.rowCount > 0) {
						var emailList = [],
							interval = parseInt(req.query.days),
							message = 'The following Contact has requested an account: ',
							subject = 'Maponics Feedback Contact Requests';

						result.rows.forEach(function (row) {
							emailList.push(row.email);
							return true;
						});
/*
						if (interval == 0)
							message = 'The following Contacts have requested accounts today:';
						else if (interval == 1)
							message = 'The following Contacts have requested accounts since yesterday:';
						else if (interval > 1)
							message = 'The following Contacts have requested accounts in the past ' + interval + ' days:';
*/
						message += '<br />\n\
<table style="text-align: left; width:100%; border: 1px solid;">\
	<tr style="text-align: left;" >\
		<th style="border-bottom: 2px solid;">First</th>\
		<th style="border-bottom: 2px solid;">Last</th>\
		<th style="border-bottom: 2px solid;">Email</th>\
		<th style="border-bottom: 2px solid;">Organization</th>\
		<th style="border-bottom: 2px solid;">Phone</th>\
		<th style="border-bottom: 2px solid;">Date</th>\
	</tr>';
						requestList.forEach(function( r ) {
							message += '\n\
	<tr>\
		<td>'+ r.first_name +'</td>\
		<td>'+ r.last_name +'</td>\
		<td>'+ r.email +'</td>\
		<td>'+ r.organization +'</td>\
		<td>'+ r.phone +'</td>\
		<td>'+ new Date(r.modified * 1000).toString().slice(4, 15) +'</td>\
	</tr>';
						});
						message += '\n</table>';
						
						Contact.notify(emailList.join('; '), subject, message);

					} else if (result.rowCount == 0) {
						Debugger.on = true;
						Debugger.log('No rows received for: \n' + sql);
					}

					return done();
				});
			}

			return true;
		});

		return true;
	};

	Contact.query = function (req, res, callback, client, done, sql, param) {
		if (param === undefined)
			client.query(sql, function (error, result) {
				Contact.queryResult(req, res, callback, error, result, sql);
			});

		else
			client.query(sql, param, function (error, result) {
				Contact.queryResult(req, res, callback, error, result, sql);
			});

		return done();
	};

	Contact.queryResult = function (req, res, callback, error, result, sql) {
		if (error)
			pg.contactError(error, res, sql);

		else if (result.rowCount > 0) {
			if (parseInt(page) !== parseInt(page) || parseInt(page) < 1)
				page = 0;

			var i = ( page > 0 ) ? (page - 1) * 100 : 0,
				p = ( page > 0 ) ? (page) * 100 : result.rowCount,
				contactsList = [];

			for (; i < p && i < result.rowCount; i++) {
				var contactData = ( 'cid' in result.rows[i] ) ? result.rows[i] : false,
					contactObject = new Contact(contactData);
				/* Because Pete wants sanitized data to be reverted
				 * to original type and form, must return escaped
				 * chars back to raw chars and parse json property
				 * as a GeoJSON object.
				 */
				for (var prop in contactObject) {
					if (typeof contactObject[prop] === 'string') {
						contactObject[prop] = contactObject[prop]
							.replace(/\&apos\;/g, "'")
							.replace(/\&quot\;/g, "'");  // From when mismatched HTML entity was used
					}
				}

				contactsList.push(contactObject);
			}

			if (req.confirm) {
				contactsList.forEach(function (contact) {
					req.that = contact;					
					req.oldEmail = contact.email;
					contact.confirmUpdate(req, res);

					return true;
				});

			} else if (typeof callback === 'function') {	// Use custom callback function
				contactsList.forEach(function (contact) {
					if ('cid' in contact)
						res.contact = contact;

					return true;
				});

				callback(req, res);

			} else {
				res.status(200).send(contactsList);
			}

		} else if (result.rowCount == 0) {
			Debugger.on = true;
			Debugger.log('No rows received for: \n' + sql);
			res.status(200).send([]);
		}

		return true;
	};

	/**
	 * Set the Contacts object 'deleted' field to 'true' by a specified cid
	 *
	 * @param {string} apikey Unique Identifier for software developers accessing the Maponics Crowdsourcing API
	 * @param {number} cid Unique Identifier for individual record in Contacts
	 * @returns {Array} Array of Summary objects
	 * @memberOf Contact
	 * @example
	 *        {HOST}/contact/deleteContactById?cid=1&apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 *
	 */
	function deleteContactById(req, res) {
		var cid = parseInt(req.query.cid);

		if (cid !== cid)
			pg.contactError('Must provide valid \'cid\' number', res, '');

		else
			pg.connect(req.connection, function (error, client, done) {
				var sql =
					'UPDATE ' + config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" ' +
					'SET ' +
						'deleted = ' + true + ', ' +
						'modified = CURRENT_TIMESTAMP ' +
					'WHERE cid = $1 ' +
					'RETURNING ' +
						'cid, ' +
						'first_name, ' +
						'last_name, ' +
						'role, ' +
						'organization, ' +
						'email, ' +
						'phone, ' +
						'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
						'DATE_PART(\'epoch\', created) AS created, ' +
						'DATE_PART(\'epoch\', modified) AS modified, ' +
						'deleted;';

				if (error)
					pg.contactError(error, res, sql);
				else
					Contact.query(req, res, null, client, done, sql, [cid]);

				return true;
			});

		return true;
	}

	/**
	 * GET an array of Contact objects representing all saved contacts.
	 * This is also the default method for the '/contact' route. <em>Optional:</em>
	 * For large results sets the page parameter specifies which factor of 100 Contact
	 * objects should be included (i.e. for a results set of 300 or more objects,
	 * page=3 will return an array containing the 201st to the 300th object)
	 *
	 * @param {string} apikey Unique Identifier for software developers accessing the Maponics Crowdsourcing API
	 * @param {Number} page* <em>Optional</em> paging factor
	 * @returns {Array} Array of Contact objects
	 * @memberOf Contact
	 * @example
	 *        {HOST}/contact/getAllContacts?page=1&apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 *
	 */
	function getAllContacts(req, res) {
		pg.connect(req.connection, function (error, client, done) {
			var sql =
				'SELECT ' +
					'c.cid, ' +
					'c.first_name, ' +
					'c.last_name, ' +
					'c.role, ' +
					'o.name AS organization, ' +
					'c.email, ' +
					'c.phone, ' +
					'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
					'DATE_PART(\'epoch\', c.created) AS created, ' +
					'DATE_PART(\'epoch\', c.modified) AS modified, ' +
					'c.deleted AS deleted ' +
				'FROM ' +
					config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" c, ' +
					config[req.hostname].organization.schema + '."' + config[req.hostname].organization.table + '" o ' +
				'WHERE c.organization = o.id ' +
				'ORDER BY c.cid;';

			if (error)
				pg.contactError(error, res, sql);
			else
				Contact.query(req, res, null, client, done, sql);

			return true;

		});

		return true;
	}

	/**
	 * GET Contacts data dictionary
	 *
	 * @param {string} apikey Unique Identifier for software developers accessing the Maponics Crowdsourcing API
	 * @returns {Array} Array of Contacts data dictionary objects
	 * @memberOf Contact
	 * @example
	 *        {HOST}/contact/getDataDictionary?apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 *
	 */
	function getDataDictionary(req, res) {
		pg.connect(req.connection, function (error, client, done) {
			var sql =
				'SELECT ' +
					'column_name, ' +
					'data_type ' +
				'FROM information_schema.columns ' +
				'WHERE table_schema = $1 ' +
					'AND table_name = $2;';

			if (error)
				pg.contactError(error, res, sql);
			else
				client.query(sql, [config[req.hostname].contact.schema, config[req.hostname].contact.table], function (error, result) {
					if (error)
						pg.contactError(error, res, sql);

					else if (result.rowCount > 0)
						res.status(200).send(result.rows);

					else if (result.rowCount == 0) {
						Debugger.on = true;
						Debugger.log('No rows received for: \n' + sql);
						res.status(200).send([]);
					}

					return done();
				});

			return true;
		});

		return true;
	}

	/**
	 * GET the Contact object selected by a specified email address
	 *
	 * @param {string} apikey Unique Identifier for software developers accessing the Maponics Crowdsourcing API
	 * @param {string} email Email address for individual Contact
	 * @returns {Array} Array with single Contact object
	 * @memberOf Contact
	 * @example
	 * 		{HOST}/contact/getByEmail?email=first@testers.com&apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 *
	 */
	function getByEmail(req, res, callback) {
		var email = req.query.email;

		if (typeof email !== 'string')
			pg.contactError('Must provide valid \'email\' address: ' + email, res, '');

		else
			pg.connect(req.connection, function (error, client, done) {
				email = email.replace(/["|']/g, '');

				var sql =
					'SELECT ' +
						'c.cid, ' +
						'c.first_name, ' +
						'c.last_name, ' +
						'c.role, ' +
						'o.name AS organization, ' +
						'c.email, ' +
						'c.phone, ' +
						'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
						'DATE_PART(\'epoch\', c.created) AS created, ' +
						'DATE_PART(\'epoch\', c.modified) AS modified, ' +
						'c.deleted AS deleted ' +
					'FROM ' +
						config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" c, ' +
						config[req.hostname].organization.schema + '."' + config[req.hostname].organization.table + '" o ' +
					'WHERE c.email = $1 ' +
						'AND c.organization = o.id;';

				if (error)
					pg.contactError(error, res, sql);
				else
					Contact.query(req, res, callback, client, done, sql, [email]);

				return true;
			});

		return true;
	}

	/**
	 * GET the Contact object selected by a specified cid
	 *
	 * @param {string} apikey Unique Identifier for software developers accessing the Maponics Crowdsourcing API
	 * @param {number} cid Unique Identifier for individual record in Contacts
	 * @returns {Array} Array with single Contact object
	 * @memberOf Contact
	 * @example
	 *        {HOST}/contact/getById?cid=1&apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 *
	 */
	function getById(req, res, callback) {
		var cid = parseInt(req.query.cid);

		if (cid !== cid)
			pg.contactError('Must provide valid \'cid\' number', res, '');

		else
			pg.connect(req.connection, function (error, client, done) {
				var sql =
					'SELECT ' +
						'c.cid, ' +
						'c.first_name, ' +
						'c.last_name, ' +
						'c.role, ' +
						'o.name AS organization, ' +
						'c.email, ' +
						'c.phone, ' +
						'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
						'DATE_PART(\'epoch\', c.created) AS created, ' +
						'DATE_PART(\'epoch\', c.modified) AS modified, ' +
						'c.deleted AS deleted ' +
					'FROM ' +
						config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" c, ' +
						config[req.hostname].organization.schema + '."' + config[req.hostname].organization.table + '" o ' +
					'WHERE c.cid = $1 ' +
						'AND c.organization = o.id;';

				if (error)
					pg.contactError(error, res, sql);
				else
					Contact.query(req, res, callback, client, done, sql, [cid]);

				return true;
			});

		return true;
	}

	/**
	 * RESET the login password of the Contact object selected by a specified email address
	 *
	 * @param {string} apikey Unique Identifier for software developers accessing the Maponics Crowdsourcing API
	 * @param {string} email Email address for individual Contact
	 * @returns {Array} Array with single Contact object
	 * @memberOf Contact
	 * @example
	 * 		{HOST}/contact/resetByEmail?email=somebody@company.com&apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 *
	 */
	function resetByEmail(req, res) {
		var email = req.query.email;

		if (typeof email !== 'string') {
			pg.contactError('Must provide valid \'email\' address: ' + email, res, '');

		} else {
			pg.connect(req.connection, function (error, client, done) {
				email = email.replace(/["|']/g, '');

				var sql =
					'SELECT ' +
						'c.cid AS cid, ' +
						'c.first_name AS first_name, ' +
						'c.last_name AS last_name, ' +
						'c.role AS role, ' +
						'o.name AS organization, ' +
						'c.email AS email, ' +
						'c.phone AS phone, ' +
						'TO_CHAR(c.join_date, \'DD MONTH YYYY\') AS join_date, ' +
						'DATE_PART(\'epoch\', c.created) AS created, ' +
						'DATE_PART(\'epoch\', c.modified) AS modified, ' +
						'c.deleted AS deleted ' +
					'FROM ' +
						config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" c, ' +
						config[req.hostname].organization.schema + '."' + config[req.hostname].organization.table + '" o ' +
					'WHERE c.email = $1 ' +
						'AND c.organization = o.id;';

				if (error) {
					pg.contactError(error, res, sql);

				} else {
					client.query(sql, [email], function (error, result) {
						Debugger.on = true;
						Debugger.log( "Attempting reset for "+ email );

						if (error)
							pg.contactError(error, res, sql);

						else if (result.rowCount > 0) {
							for (var i = 0; i < result.rowCount; i++) {
								var contactData = ( 'cid' in result.rows[i] ) ? result.rows[i] : false,
									contactObject = new Contact(contactData);

								for (var prop in contactObject) {
									if (typeof contactObject[prop] === 'string') {
										contactObject[prop] = contactObject[prop]
											.replace(/\&apos\;/g, "'")
											.replace(/\&quot\;/g, "'");
									}
								}

								Debugger.log(contactObject, 'resetByEmail returned: $1');

								var r = new Request(req, contactObject);
								r.cid = contactData.cid;
								r.pass = Request.createPass();
								Request.resetPass(r);
							}

							res.status(200).send({Success: 'Password reset.'});

						} else if (result.rowCount == 0) {
							Debugger.log('No rows received for: \n' + sql);
							pg.contactError('Please use the Registration form to register ' + email, res, sql);
						}

						return done();
					});
				}

				return true;
			});
		}

		return true;
	}
	
	/* this => instance properties & methods */	
	Contact.prototype.init = function(contactData) {
		Debugger.on = true;

		if (typeof contactData !== 'object') {
			this.error = 'Contact initialization requires a valid contactData object';
			Debugger.log(contactData, this.error + ': $1');

		} else if (contactData.cid !== undefined && parseInt(contactData.cid) !== parseInt(contactData.cid)) {
			Debugger.log(contactData.cid);
			delete contactData.cid;

			this.error = 'Must provide valid \'cid\' number';
			Debugger.log(contactData, this.error + ': $1');

		} else {
			this.cid = (!contactData.cid ) ? contactData.cid : parseInt(contactData.cid);	// Cannot be written to. Used in reads and updates.
			this.first_name = contactData.first_name;
			this.last_name = contactData.last_name;
			this.role = contactData.role;
			this.organization = contactData.organization;
			this.email = contactData.email;
			this.phone = contactData.phone;
			this.join_date = contactData.join_date;
			this.created = contactData.created;		// Cannot be written to. Used in reads and adds.
			this.modified = contactData.modified;
			this.deleted = contactData.deleted;

			/* Change any "null" strings to null objects */
			for (var p in this) {
				if (this[p] === "null" || this[p] === '"null"' || this[p] === "'null'")
					this[p] = null;
			}

			if (typeof this.created === 'number')
				this.created = parseInt(this.created.toString().match(/(\d+)\.*\d*/)[1]);

			if (typeof this.modified === 'number')
				this.modified = parseInt(this.modified.toString().match(/(\d+)\.*\d*/)[1]);
		}

		return this;
	};

	/**
	 * POST (Save) a pending Contact object to the Request table for admin review.
	 * <em>Request New:</em> Use the required parameters to request a new Contact.
	 *
	 * @param {string} apikey Unique Identifier for software developers accessing the Maponics Crowdsourcing API
	 * @param {string} first_name Required first name of Contact
	 * @param {string} last_name Required last name of Contact
	 * @param {string} email Required email address for Contact
	 * @param {string} phone* <em>Optional</em> phone number for Contact
	 * @param {string} organization Required organization for Contact
	 * @returns {Array} Array with single Contact object
	 * @memberOf Contact
	 * @example
	 * 		{HOST}/contact/request?first_name=First&last_name=User&email=first@testers.com&organization=great_users&apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 */
	Contact.prototype.request = function request(req, res) {
		try {
			if (this.error)
				pg.contactError(this.error, res, '');

			else {
				var confirm,
					contact = this;

				if (req.query.confirm)
					confirm = req.query.confirm.replace(/["|']/g, '').replace(/'/g, '&apos;');

				if (this.cid && typeof confirm === 'string')
					/* Attempt to update existing Contact */
					Contact.requestUpdate(req, res, confirm, contact);

				else if (this.cid && parseInt(this.cid) > 0) {
					/* Confirm update of existing Contact */
					req.confirm = true;
					req.that = contact;
					getById(req, res);

				} else
					/* Attempt to save New Contact */
					Contact.requestInsert(req, res, contact);
			}

			return this;

		} catch (e) {
			Debugger.on = true;
			Debugger.log(e.stack);
		}
	};

	Contact.requestInsert = function (req, res, contact) {
		if (typeof contact.first_name !== 'string')
			pg.contactError('Must provide valid \'first_name\'', res, '');

		else if (typeof contact.last_name !== 'string')
			pg.contactError('Must provide valid \'last_name\'', res, '');

		else if (typeof contact.email !== 'string')
			pg.contactError('Must provide valid \'email\' address', res, '');

		else if (typeof contact.organization !== 'string')
			pg.contactError('Must provide valid \'organization\' name', res, '');

		else
			pg.connect(req.connection, function (error, client, done) {
				var index = 1,
					param = [],
					fields = '',
					values = '';

				for (var prop in contact) {
					if (contact[prop] !== undefined && typeof contact[prop] === 'string' && typeof contact[prop] !== 'function') {
						fields += prop + ', ';
						values += '$' + index + ', ';

						param.push(contact[prop].replace(/["|']/g, '').replace(/'/g, '&apos;'));
						index++;
					}
				}

				var sql =
					'INSERT INTO ' + config[req.hostname].request.schema + '."' + config[req.hostname].request.table + '" (' +
						 fields +
						'created, ' +
						'modified) ' +
					'VALUES (' +
						 values +
						'CURRENT_TIMESTAMP, ' +
						'CURRENT_TIMESTAMP) ' +
					'RETURNING ' +
						 fields +
						'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
						'DATE_PART(\'epoch\', created) AS created, ' +
						'DATE_PART(\'epoch\', modified) AS modified;';

				if (error) {
					pg.contactError(error, res, sql);

				} else {
					client.query(sql, param, function (error, result) {
						if (error && error.message.match(/Contacts_unique_email/) === null)
							pg.contactError(error, res, sql);

						else if (error && error.message.match(/Contacts_unique_email/) !== null) {
							/* This email already exists, so confirm update of existing Contact */
							req.confirm = true;
							req.that = contact;
							getByEmail(req, res);

						} else if (result.rowCount > 0) {
							var contactsList = [];

							for (var i = 0; i < result.rowCount; i++) {
								var contactData = ( 'email' in result.rows[i] ) ? result.rows[i] : false,
									contactObject = new Contact(contactData);

								for (var prop in contactObject) {
									if (typeof contactObject[prop] === 'string') {
										contactObject[prop] = contactObject[prop]
											.replace(/\&apos\;/g, "'")
											.replace(/\&quot\;/g, "'");
									}
								}

								contactsList.push(contactObject);
							}

							res.status(200).send(contactsList);
							
							/* Notify manager of new contact request */
							Contact.notifyManager(req, contactsList);

						} else if (result.rowCount == 0) {
							Debugger.on = true;
							Debugger.log('No rows received for: \n' + sql);
							res.status(200).send([]);
						}

						return done();
					});
				}

				return true;
			});

		return true;
	};

	Contact.requestUpdate = function (req, res, confirm, contact) {
		Debugger.on = true;

		if (contact.confirm !== confirm && confirm !== md5(JSON.stringify(contact))) {
			var error = '';

			if (req.confirmError)
				error =
					'Confirmation key ' + confirm + ' does not match Contact object. ' +
					'Please provide these query keys and values as listed: ' +
					'cid, email, first_name, last_name, organization, phone, confirm';
			else
				error =
					'1 Confirmation key ' + confirm + ' does not match on first try. Trying again...';

			Debugger.log(contact, error + ':\n $1');

			req.confirm = true;
			req.confirmError = error;

			req.that = contact;
			req.that.confirm = md5(JSON.stringify(contact));

			if (contact.email)
				return getByEmail(req, res);

		} else if (typeof contact.first_name !== 'string')
			pg.contactError('Must provide valid \'first_name\'', res, '');

		else if (typeof contact.last_name !== 'string')
			pg.contactError('Must provide valid \'last_name\'', res, '');

		else if (typeof contact.email !== 'string')
			pg.contactError('Must provide valid \'email\' address', res, '');

		else if (typeof contact.organization !== 'string')
			pg.contactError('Must provide valid \'organization\' name', res, '');

		else
			pg.connect(req.connection, function (error, client, done) {
				var index = 1,
					param = [],
					set = '';

				for (var prop in contact) {
					if (prop !== 'confirm' && contact[prop] !== undefined && typeof contact[prop] === 'string' && typeof contact[prop] !== 'function') {
						if (prop != 'email') {
							set += prop + ' = $' + index + ', ';
							param.push(contact[prop].replace(/["|']/g, '').replace(/'/g, '&apos;'));
							index++;
						}
/*
						if (prop != 'email')
							set += prop + ' = $' + index + ', ';

						param.push(contact[prop].replace(/["|']/g, '').replace(/'/g, '&apos;'));
						index++;
*/
					}
				}

				var sql =
					'UPDATE ' + config[req.hostname].request.schema + '."' + config[req.hostname].request.table + '" ' +
					'SET ' +
						 set +
						'modified = CURRENT_TIMESTAMP ' +
					'WHERE email = $1 ' +
					'RETURNING ' +
						'first_name, ' +
						'last_name, ' +
						'email, ' +
						'phone, ' +
						'organization, ' +
						'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
						'DATE_PART(\'epoch\', created) AS created, ' +
						'DATE_PART(\'epoch\', modified) AS modified;';

				if (error) {
					pg.contactError(error, res, sql);

				} else {
					client.query(sql, param, function (error, result) {
						if (error)
							pg.contactError(error, res, sql);

						else if (result.rowCount > 0) {
							var contactsList = [];

							for (var i = 0; i < result.rowCount; i++) {
								var contactData = ( 'email' in result.rows[i] ) ? result.rows[i] : false,
									contactObject = new Contact(contactData);

								for (var prop in contactObject) {
									if (typeof contactObject[prop] === 'string') {
										contactObject[prop] = contactObject[prop]
											.replace(/\&apos\;/g, "'")
											.replace(/\&quot\;/g, "'");
									}
								}

								contactsList.push(contactObject);
							}

							res.status(200).send(contactsList);

						} else if (result.rowCount == 0) {
							Debugger.log('No rows received for: \n' + sql);
							res.status(200).send([]);
						}

						return done();
					});
				}

				return true;
			});

		return true;
	};

	/**
	 * POST (Save) the Contact object defined by specified parameters.
	 * <em>Create New:</em> Use the required parameters to create a new Contact.
	 * <em>Update Exisiting:</em> If a cid is provided, will attempt to use the
	 * specified parameters to update the existing record in Contacts, if any.
	 * Updating a Contact requires two (2) method calls, the first to specify
	 * which record and paramaters to update, which returns a complete Contact
	 * object and an additional key (confirm). Posting a second method call with
	 * these parameters and the provided key will confirm the intended update.
	 *
	 * @param {string} apikey Unique Identifier for software developers accessing the Maponics Crowdsourcing API
	 * @param {number} cid* <em>Optional</em> Identifier for individual record in Contacts - used to update existing Contact
	 * @param {string} first_name Required first name of Contact
	 * @param {string} last_name Required last name of Contact
	 * @param {string} email Required email address for Contact
	 * @param {string} phone* <em>Optional</em> Phone number for Contact
	 * @param {string} organization Required organization for Contact
	 * @param {string} confirm* <em>Optional</em> Required key for updating a Contact
	 * @returns {Array} Array with single Contact object
	 * @memberOf Contact
	 * @example
	 *        {HOST}/contact/save?first_name=John&last_name=Smith&email=somebody@company.com&organization=Maponics LLC&apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 * @example
	 *        {HOST}/contact/save?apikey=051404be-5e60-4407-b1cf-fb92098ff98e
	 *
	 *            {
	 *				"cid" : 1,
	 *				"email" : "first@testers.com",
	 *				"first_name" : "Joe",
	 *				"last_name" : "Doe",
	 *				"organization" : "great_users",
	 *				"phone" : " ",
	 *				"confirm" : "11ea470b4a8eb7fdb9d823910fda6a48"
	 *			}
	 *
	 */
	Contact.prototype.save = function save(req, res, callback) {
		try {
			if (this.error) {
				pg.contactError(this.error, res, '');

			} else {
				var confirm,
					contact = this;

				if (req.query.confirm) {
					Debugger.on = true;
					confirm = req.query.confirm.replace(/["|']/g, '');
				}
					
				if (this.cid && parseInt(this.cid) > 0 && typeof confirm === 'string') {				
					/* Attempt to update existing Contact */
					if (contact.email && !req.confirm) {
						req.oldEmail = req.oldEmail || '';
						req.newEmail = req.newEmail || contact.email;

						req.confirm = true;

						req.that = contact;
						req.that.confirm = md5(JSON.stringify(req.that));

						if (contact.cid) {
							req.query.cid = contact.cid;
							getById(req, res);
						}

					} else
						Contact.saveUpdate(req, res, contact, callback);

				} else if (this.cid && parseInt(this.cid) > 0) {					
					/* Confirm update of existing Contact */
					if (contact.email && !req.confirm) {
						req.oldEmail = req.oldEmail || '';
						req.newEmail = req.newEmail || contact.email;
					}

					req.confirm = true;
					req.confirmError = 'Must provide confirmation key (confirm)';
					
					req.that = contact;
					req.that.confirm = md5(JSON.stringify(req.that));

					if (contact.cid) {
						req.query.cid = contact.cid;
						getById(req, res);
					}

				} else Contact.saveInsert(req, res, contact, callback);
				
			}

			return this;

		} catch (e) {
			Debugger.on = true;
			Debugger.log(e.stack);
		}
	};

	Contact.saveInsert = function (req, res, contact, callback) {
		Debugger.on = true;
		
		var callback = callback;
		
		if (typeof contact.first_name !== 'string')
			pg.contactError('Must provide valid \'first_name\'', res, '');

		else if (typeof contact.last_name !== 'string')
			pg.contactError('Must provide valid \'last_name\'', res, '');

		else if (typeof contact.email !== 'string')
			pg.contactError('Must provide valid \'email\' address', res, '');

		else if (typeof contact.organization !== 'string')
			pg.contactError('Must provide valid \'organization\' name', res, '');

		else {
			if (contact.organization && typeof contact.organization === 'string')
				contact.organization = contact.organization.replace(/["|']/g, '').replace(/'/g, '&apos;');
			
			var localhost = ( req.hostname === "feedback.maponics.com" )? "localhost" : req.hostname;

			var options = {
				headers: {
					'Content-Type': 'application/json'
				},
				url: 'http://'+ localhost +':8000/organization/add?apikey='+ config.apiKey +'&name='+ contact.organization
			};

			request.get(options, function (error, response) {
				if (error) {
					pg.contactError(error.message, response, '');

				} else if( (response.statusCode == 200) && (response.body !== undefined) ) {
					pg.connect(req.connection, function (error, client, done) {
						var index = 1,
							param = [],
							fields = '',
							values = '';
						
						Debugger.log( response.body );

						contact.organization = JSON.parse(response.body).id;

						for (var prop in contact) {
							if (contact[prop] !== undefined && typeof contact[prop] !== 'function') {
								fields += prop + ', ';
								values += '$' + index + ', ';

								if (typeof contact[prop] === 'number')
									param.push(parseInt(contact[prop]));

								else if (typeof contact[prop] === 'string')
									param.push(contact[prop].replace(/["|']/g, '').replace(/'/g, '&apos;'));

								index++;
							}
						}

						var sql =
							'INSERT INTO ' + config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" (' +
								 fields +
								'created, ' +
								'modified) ' +
							'VALUES (' +
								 values +
								'CURRENT_TIMESTAMP, ' +
								'CURRENT_TIMESTAMP) ' +
							'RETURNING ' +
								'cid, ' +
								'role, ' +
								 fields +
								'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
								'DATE_PART(\'epoch\', created) AS created, ' +
								'DATE_PART(\'epoch\', modified) AS modified, ' +
								'deleted;';
						
						if (error) {
							pg.contactError(error, res, sql);
							
						} else {
							client.query(sql, param, function (error, result) {
								req.that = contact;

								if (error && error.message.match(/Contacts_unique_email/) === null) {
									pg.contactError(error, res, sql);

								} else if (error && error.message.match(/Contacts_unique_email/) !== null) {
									/* This email already exists, so confirm update of existing Contact */

									if (typeof callback === 'function') {	// Use custom callback function
										req.that.error = error;
										req.query.email = contact.email;
										getByEmail(req, res, callback);

									} else {
										req.confirm = true;
										getByEmail(req, res);
									}

								} else if (result.rowCount > 0) {
									var contactsList = [];
									
									Debugger.log( "Callback is "+ typeof callback );

									result.rows.forEach(function (row) {
										if ('cid' in row)
											contact.cid = parseInt(row.cid);

										return true;
									});

									for (var i = 0; i < result.rowCount; i++) {
										var contactData = ( 'cid' in result.rows[i] ) ? result.rows[i] : false,
											contactObject = new Contact(contactData);

										for (var prop in contactObject) {
											if (typeof contactObject[prop] === 'string') {
												contactObject[prop] = contactObject[prop]
													.replace(/\&apos\;/g, "'")
													.replace(/\&quot\;/g, "'");

											}
										}
										
										res.that = contactObject;

										contactsList.push(contactObject);
									}

									if (typeof callback === 'function') {
										Debugger.log( "Running callback: "+ callback );
										callback(req, res);
									} else {
										res.status(200).send(contactsList);
									}

								} else if (result.rowCount == 0) {
									Debugger.on = true;
									Debugger.log('No rows received for: \n' + sql);

									if (typeof callback === 'function')
										callback(req, res);
									else
										res.status(200).send([]);
								}

								return done();
							});
						}

						return true;
					});

				} else pg.contactError(response.statusCode.toString() + ': ' + response.message, response, '');

				return true;
			});
		}

		return true;
	};

	Contact.saveUpdate = function (req, res, contact, callback) {
		Debugger.on = true;
        /* The logic of the saveUpdate transaction is currently broken. Specifically,
         * the order of operations is incorrect. The Organizations table should be 
         * queried for the name string value *before* making an update to the record
         * in Contacts and also *before* creating a hash value of the existing record
         * in Contacts to be compared against the value of the supplied confirm key.
         * We will fix this in subsequent commits.
         */
		
		var confirm,
			callback = callback;

		if (req.query.confirm) confirm = req.query.confirm.replace(/["|']/g, '');

		if( contact.confirm && (contact.confirm !== confirm) && (confirm !== md5( JSON.stringify(contact))) ) {
			var error = '';

			if (req.confirmError) {
				error =
					'Confirmation key ' + confirm + ' does not match Contact object. ' +
					'Please provide these query keys and values as listed: ' +
					'cid, email, first_name, last_name, organization, phone, confirm';
			} else {
				error =
					'1 Confirmation key ' + confirm + ' does not match on first try. Trying again...';

				Debugger.log(contact, error + ':\n $1');

				req.confirm = true;
			}
				
			req.confirmError = error;

			req.that = contact;
			req.that.confirm = md5(JSON.stringify(req.that));

			if (contact.cid) return getById(req, res);
			else if (contact.email) return getByEmail(req, res);

		}
		
		if (typeof contact.first_name !== 'string')
			pg.contactError('Must provide valid \'first_name\'', res, '');

		else if (typeof contact.last_name !== 'string')
			pg.contactError('Must provide valid \'last_name\'', res, '');

		else if (typeof contact.email !== 'string')
			pg.contactError('Must provide valid \'email\' address', res, '');
/*		
		// Ingnoring organization updates for now, until we sort this out.
		else if (typeof contact.organization !== 'string')
			pg.contactError('Must provide valid \'organization\' name', res, '');
*/
		else if(! error ) pg.connect(req.connection, function (error, client, done) {
				var index = 1,
					param = [],
					set = '';

				for (var prop in contact) {
					if (prop === 'organization' ) delete contact.organization;
					
					if (prop !== 'confirm' && contact[prop] !== undefined && typeof contact[prop] !== 'function') {
						if (prop == 'cid' && typeof contact[prop] === 'number')
							param.push(parseInt(contact[prop]));

						else if (typeof contact[prop] === 'string') {
							set += prop + ' = $' + index + ', ';
							param.push(contact[prop].replace(/["|']/g, '').replace(/'/g, '&apos;'));
						}

						index++;
					}
				}

				var sql =
					'UPDATE ' + config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" ' +
					'SET ' +
						 set +
						'modified = CURRENT_TIMESTAMP ' +
					'WHERE cid = $1 ' +
					'RETURNING ' +
						'cid, ' +
						'first_name, ' +
						'last_name, ' +
						'role, ' +
						'organization, ' +
						'email, ' +
						'phone, ' +
						'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
						'DATE_PART(\'epoch\', created) AS created, ' +
						'DATE_PART(\'epoch\', modified) AS modified, ' +
						'deleted;';

				if (error) {
					pg.contactError(error, res, sql);
					
				} else {
					client.query(sql, param, function (error, result) {
						if (error) {
							pg.contactError(error, res, sql);

						} else if (result.rowCount > 0) {

//							result.rows.forEach(function (row) {
//								if ('organization' in row)
//									contact.id = parseInt(row.organization);

//								return true;
//							});

//							var options = {
//								headers: {
//									'Content-Type': 'application/json'
//								},
//								url: 'http://localhost:8000/organization/update?apikey=' + config.apiKey + 
//									'&id=' + contact.id + '&name=' + contact.organization
//							};
//
//							request.get(options, function (error, response) {
//								if (error)
//									pg.contactError(error.message, response, '');
//
//								else if (response.statusCode == 200 && response.body !== undefined)
									pg.connect(req.connection, function (error, client, done) {
										var sql =
											'SELECT ' +
												'c.cid, ' +
												'c.first_name, ' +
												'c.last_name, ' +
												'c.role AS role, ' +
												'o.name AS organization, ' +
												'c.email, ' +
												'c.phone, ' +
												'TO_CHAR(join_date, \'DD MONTH YYYY\') AS join_date, ' +
												'DATE_PART(\'epoch\', c.created) AS created, ' +
												'DATE_PART(\'epoch\', c.modified) AS modified, ' +
												'c.deleted AS deleted ' +
											'FROM ' +
												config[req.hostname].contact.schema + '."' + config[req.hostname].contact.table + '" c, ' +
												config[req.hostname].organization.schema + '."' + config[req.hostname].organization.table + '" o ' +
											'WHERE c.cid = $1 ' +
												'AND c.organization = o.id;';

										if (error) {
											pg.contactError(error, res, sql);
											
										} else {
											client.query(sql, [parseInt(contact.cid)], function (error, result) {
												if (error)
													pg.contactError(error, res, sql);

												else if (result.rowCount > 0) {
													var contactsList = [];

													for (var i = 0; i < result.rowCount; i++) {
														var contactData = ( 'cid' in result.rows[i] ) ? result.rows[i] : false,
															contactObject = new Contact(contactData);

														for (var prop in contactObject) {
															if (typeof contactObject[prop] === 'string') {
																contactObject[prop] = contactObject[prop]
																	.replace(/\&apos\;/g, "'")
																	.replace(/\&quot\;/g, "'");
															}
														}

														if (req.newEmail !== req.oldEmail)
															new Request(req, contactData).update(contactObject.cid, req.newEmail, req.oldEmail);

														res.that = contactObject;

														contactsList.push(contactObject);
													}

													if (typeof callback === 'function') {
														Debugger.log( "Running callback: "+ callback );
														callback(req, res);
													} else {
														res.status(200).send(contactsList);
													}

												} else if (result.rowCount == 0) {
													Debugger.log('No rows received for: \n' + sql);
													res.status(200).send([]);
												}

												return done();
											});
										}

										return true;
									});

//								else
//									pg.contactError(response.message, response, '');
//
//								return true;
//							});

						} else if (result.rowCount == 0) {
							Debugger.log('No rows received for: \n' + sql);
							res.status(200).send([]);
						}

						return done();
					});
				}

				return true;
			});

		return true;
	};

	Contact.prototype.confirmUpdate = function (req, res) {
		/* Verfiy updated parameters (from req) */
		var updates = {
			cid: parseInt(req.that.cid) || parseInt(this.cid),
			email: req.that.email || this.email,
			first_name: req.that.first_name || this.first_name,
			last_name: req.that.last_name || this.last_name,
			phone: req.that.phone || this.phone,
			organization: req.that.organization || this.organization
		};

		if (req.newEmail) {
			Debugger.on = true;
			Debugger.log({
				newEmail: req.newEmail,
				oldEmail: req.oldEmail
			});
			
			updates.email = req.newEmail;
		}

		updates = new Contact(updates);
		updates.confirm = md5(JSON.stringify(updates));

		if( req.confirm && !req.confirmError ) {
			updates.save(req, res);

		} else if( req.confirm && req.confirmError.match(/^1/) !== null ) {
			updates.save(req, res);

		} else {
			updates.error = req.confirmError;
			
			Debugger.log( updates );

			res.status(200).send([updates]);
		}

		return this;
	};

	Debugger.on = false;

	if (typeof req !== 'object' && typeof contactData === 'object')
		return this.init(contactData);
	else if (req.path.match(/\/(?:request)/) !== null)
		return (new Contact(contactData)).request(req, res);
	else if (req.path.match(/\/(?:save)/) !== null)
		return (new Contact(contactData)).save(req, res);
	else if (req.path.match(/\/(?:reset)/) !== null)
		return resetByEmail(req, res);
	else if (req.path.match(/\/(?:deleteContactById)/) !== null)
		return deleteContactById(req, res);
	else if (req.path.match(/\/(?:getAllContacts)/) !== null)
		return getAllContacts(req, res);
	else if (req.path.match(/\/(?:getDataDictionary)/) !== null)
		return getDataDictionary(req, res);
	else if (req.path.match(/\/(?:getByEmail)/) !== null)
		return getByEmail(req, res);
	else if (req.path.match(/\/(?:getById)/) !== null)
		return getById(req, res);
	else
		return getAllContacts(req, res);
}

module.exports = Contact;
